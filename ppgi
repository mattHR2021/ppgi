#!/usr/bin/env bash

###############################################################################
#### C O N S T A N T S ########################################################
###############################################################################
####[ ppgi install DIR ]####
############################

####[ GitHub  UserName ]####
############################

####[ HackReactor path ]####
############################
###############################################################################

###############
# script_path #
###############
abspath() {
    # generate absolute path from relative path
    # $1     : relative filename
    # return : absolute path
    if [ -d "$1" ]; then
        # dir
        (cd "$1" || return; pwd)
    elif [ -f "$1" ]; then
        # file
        if [[ $1 = /* ]]; then
            echo "$1"
        elif [[ $1 == */* ]]; then
            echo "$(cd "${1%/*}" || return; pwd)/${1##*/}"
        else
            echo "$(pwd)/$1"
        fi
    fi
}
script_path="$(abspath "${0}")"
_sed="$(command -v sed)"

#############
# UnInstall #
#############
# remove installed dependencies ? ONLY if installed by this script
if [ "$1" = "uninstall" ]; then
  if grep -q 'alias pomander' ~/.bash_aliases; then
    printf '%s\n' "removing pomander from bash aliases"
    if "$_sed" -i '/alias pomander/d' ~/.bash_aliases; then
      printf '%s\n\n' "pomander alias successfully removed"
    fi
  fi
  if grep -q 'alias cdh' ~/.bash_aliases; then
    printf '%s\n' "removing cdh from bash aliases"
    if "$_sed" -i '/alias cdh/d' ~/.bash_aliases; then
      printf '%s\n\n' "cdh alias successfully removed"
    fi
  fi
  if [ -n "$ppgi_path" ]; then
    #"$_sed" -i '/ppgi_path/' "$script_path"
    printf '%s\n' "removing ppgi from path"
    if (sudo rm "$ppgi_path"); then
      printf '%s\n\n' "ppgi successfully removed from \$PATH"
    fi
  fi
  if [ -n "$mine_gitu" ]; then
    "$_sed" -i '/^mine_gitu="/d' "$script_path"
    printf '%s\n\n' "mine_gitu var successfully removed"
  fi
  if [ -n "$hack_path" ]; then
    "$_sed" -i '/^hack_path="/d' "$script_path"
    printf '%s\n\n' "hack_path var successfully removed"
  fi
  if [ -n "$ppgi_path" ]; then
    "$_sed" -i '/^ppgi_path="/d' "$script_path"
    printf '%s\n\n' "ppgi_path var successfully removed"
  fi
  printf '%s\n' "uninstalled successfully."
  exit 0
fi

###############################################################################
# functions #
###############################################################################
# forced choice, cannot continue without accepting
choose() {
  printf '%s\n%s\n%s\n' "press <enter> to accept" "     Y: $1" "     n: $2"
  read -r -p "[Y/n]?: " response
  if [ "$response" = "n" ] || [ "$response" = "N" ]; then
    choose "$1" "$2"
  else
    return 0
  fi
}
# accept default, or customize
custom_choice() {
  "$1"
  yes_no "$2" "$3"
  if [ "$?" -eq 1 ]; then
    custom_choice "$1" "$2" "$3"
  else
    return 0
  fi
}
# optional choice, a no response allows script to continue
yes_no() {
  printf '%s\n%s\n%s\n' "press <enter> to accept" "     Y: $1" "     n: $2"
  read -r -p "[Y/n]?: " response
  if [ "$response" = "n" ] || [ "$response" = "N" ]; then
    return 1
  else
    return 0
  fi
}

# check for software dependencies
check_for() {
  _cmd=$(command -v "$1") 2>/dev/null
  if [ "$?" -eq 1 ]; then
    printf '%-12s%s\n' "${1}" "missing."
    return 1
  fi
  if [ -x "$_cmd" ]; then
    printf '%-12s%s\n' "${1}" "found!"
    return 0
  else
    printf '%-12s%s\n' "${1}" " is unexecutable."
    return 1
  fi
}

###############################################################################
##############
#    MAIN    #
##############
# skip setup #
##############
###############################################################################
if [ -n "$ppgi_path" ] && [ -n "$mine_gitu" ] && [ -n "$hack_path" ]; then
  # only list most recent 1st - awk can get the 4th? column
  #   filter by those that have h (hours) in name
  #   and find the least hours ago...
  repo_list_sorted=$(gh repo list hackreactor --private |\
              awk '/hr-rfe/ {print $3, substr($1,13)}' | sort -r)
  # this is way too much piping, should be able to do everything with awk?
  repo_latest=$(echo "$repo_list_sorted" | "$_sed" -n '1p' | awk '{print $2}')
  printf '\n%s\n\n' "latest repo: $repo_latest"
  yes_no "this is the repo I want" "give me a bigger list"
  if [ "$?" -eq 1 ]; then
    printf '\n%s\n\n' "repo's are listed in reverse chronological order"
    repo_list=$(gh repo list hackreactor --private |\
                awk -v ORS=" " '/hr-rfe/ {print substr($1,13)}')
    PS3="select HR repo: "
    select hack_repo in $repo_list; do
      case $hack_repo in
        *) printf '\n%s\n' "selected repo: ${hack_repo}"
           break;;
      esac
    done
  else
    hack_repo="${repo_latest}"
  fi
  #
  read -r -p "pair partner's git username? (ex. mattHR2021): " pair_gitu
  cd "$hack_path" || return
  gh repo fork "hackreactor/${hack_repo}"
  git clone "https://github.com/$mine_gitu/${hack_repo}.git"
  cd "$hack_repo" || return
  git remote add pair "https://github.com/$pair_gitu/${hack_repo}.git"
  git remote add upstream "https://github.com/hackreactor/${hack_repo}.git"
  # drop user to shell at cloned repo
  cd  "${hack_path}/${hack_repo}" || return
  $SHELL
  exit 0
fi
###############################################################################
#                              S E T U P                                      #
###############################################################################

# should be EXPLICIT SETUP!!!
# if $1 = "install"
# check if ppgi in path already, if so, skip

setup_banner() {
  clear
  printf '%s\n' "                          S E T U P                          "
  printf '%s\n' "#############################################################"
  printf '%s\n' "###########################[ ppgi ]##########################"
  printf '%s\n' "#############################################################"
  printf '%s\n' "Ctrl+c at anytime to exit script (SIGINT)"
  printf '\n'
}

###############################################################################
# training #
############
setup_banner
printf '%s\n'     "please READ:"
printf '%s\n'     "in this script you will be presented with CHOICES"
printf '%s\n\n'   "some mandatory (this one), some cutomizable, some optional"
printf '%s\n'     "Accept?"
choose "continue" "I can't read."

###############################################################################
# setup dependencies #
###############################################################################

# identify Operating System
setup_banner
printf '%s\n' "identifying Operating System..."
kernel_name="$(uname -s)"
case "$kernel_name" in
  Linux*)  OS='linux';;
  Darwin*) OS='macos';;
  CYGWIN*) OS='windo';;
  *)
esac

# install missing dependencies per OS
if [ "$OS" = "windo" ]; then
  printf '\n%s\n' "Windows© detected."
  printf '%s\n' "          _.-;;-._   "
  printf '%s\n' "   '-..-'|   ||   |  "
  printf '%s\n' "   '-..-'|_.-;;-._|  "
  printf '%s\n' "   '-..-'|   ||   |  "
  printf '%s\n' "   '-..-'|_.-''-._|  "
  printf '\n%s\n\n' ":["
  printf '%s\n' "https://www.privacytools.io/operating-systems/#win10"
fi

if [ "$OS" = "macos" ]; then
  printf '\n%s\n' "MacOS detected."
  printf '%s\n' "          _    "
  printf '%s\n' "        (/     "
  printf '%s\n' "  .---__--.    "
  printf '%s\n' " /         \   "
  printf '%s\n' "|         /    "
  printf '%s\n' "|         \\_  "
  printf '%s\n' " \         /   "
  printf '%s\n' "  \`._.-._.\`  "
  printf '\n%s\n'               "checking for software dependencies..."
  printf '%-12s%s\n' "PACKAGE" "STATUS"
  check_for brew
  if [ "$?" -eq 1 ]; then
    printf '%s\n' "HomeBrew not installed"
    printf '%s\n' "!!! this will take A WHILE !!!..."
    printf '%s\n' "you will know it's done when you see the ppgi setup banner"
    printf '%s\n' "this might require SU (SuperUser) permissions..."
    hb_url='https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh'
    bash -c "$(curl -fsSL ${hb_url})"
    brew update
    brew upgrade
    setup_banner
  fi
  check_for gh
  if [ "$?" -eq 1 ]; then
    brew install gh
  fi
  check_for sed
  if [ "$?" -eq 1 ]; then
    brew install gnu-sed
    "$_sed"="$(command -v gsed)"
  fi
fi

if [ "$OS" = "linux" ]; then
  if   grep -q 'Microsoft' /proc/version; then
    printf '%s\n' "Ubuntu on Windows© WSL detected. :/"
    printf '%s\n' "                                 (HALP!)                   "
    printf '%s\n' "          _.-;;-._            _  |/         _.-;;-._       "
    printf '%s\n' "   '-..-'|   ||   |       ---(_)     '-..-'|   ||   |      "
    printf '%s\n' "   '-..-'|_.-;;-._|   _/  ---  \\    '-..-'|_.-;;-._|      "
    printf '%s\n' "   '-..-'|   ||   |  (_) |   |       '-..-'|   ||   |      "
    printf '%s\n' "   '-..-'|_.-''-._|    \\  --- _/    '-..-'|_.-''-._|      "
    printf '%s\n' "                         ---(_)                            "
  elif grep -q 'Ubuntu' /proc/version; then
    printf '\n%s\n\n' "Ubuntu-based distro detected."
    printf '%s\n' "          _    "
    printf '%s\n' "    / ---(_)   "
    printf '%s\n' "  _/  ---  \\  "
    printf '%s\n' " (_) |   |   | "
    printf '%s\n' "   \\  --- _/  "
    printf '%s\n' "      ---(_)   "
  else
    printf '\n%s\n\n' "non-Ubuntu-based linux distro detected."
    printf '%s\n' "this script is only configured for Ubuntu-based distros."
    printf '%s\n' "exiting..."
    exit 1
  fi
  printf '\n%s\n'    "checking for software dependencies..."
  printf '%-12s%s\n' "PACKAGE" "STATUS"
  check_for gh
  if [ "$?" -eq 1 ]; then
    printf '%s\n' "install GitHub CLI? (y/n): "
    printf '%s\n' "this might require SU (SuperUser) permissions..."
    choose "GitHub CLI is a required software dependency, install?" "cannot continue"
    sudo apt-key adv --keyserver keyserver.ubuntu.com \
                     --recv-key C99B11DEB97541F0
    sudo apt-add-repository https://cli.github.com/packages
    sudo apt update
    sudo apt install gh
  fi
  check_for sed
  if [ "$?" -eq 1 ]; then
    # sed is part of GNU coreutils, default installed on all Ubuntu systems?
    printf '%s\n' "install sed? (y/n): "
    printf '%s\n' "this might require SU (SuperUser) permissions..."
    choose "sed is a required software dependency, install?" "cannot continue"
    sudo apt install sed
  fi
fi

printf '\n%s\n\n' "Software dependencies met. Continue?"
choose "continue" "we must go on"

###############################################################################
# setup constants #
###################

if [ -z "$mine_gitu" ]; then
  #githubusr=
  setup_banner
  git_un_pickr() {
    read -r -p "enter your github username (ex. mattHR2021): " mine_gitu
    printf '%b%s%b\n' "\e[4m\e[34m" "https://github.com/${mine_gitu}" "\e[0m"
    (("mine_length=${#mine_gitu}+19"))
    mine_length="$mine_length"
    printf "%-${mine_length}s%s\n\n" "" "|\ is THIS you?"
  }
  custom_choice git_un_pickr 'that IS me.' \
    'Imposter! ...and/or I made a typographical error, please forgive me.'
  "$_sed" -i "/^####\[ GitHub  UserName/a mine_gitu=\"$mine_gitu\"" "$script_path"
  if ! grep -q 'mine_gitu=' ./spgi; then
    "$_sed" -i "/^####\[ GitHub  UserName/a mine_gitu=\"$mine_gitu\"" ./spgi
  fi
fi

if [ -z "$hack_path" ]; then
  setup_banner
  hack_path_pickr() {
    hack_path="${HOME}/hackreactor/"
    if [ -z "$hack_path_1st" ]; then
      printf '%s\n'   "directory to clone forks of HR repos to?"
      printf '%s\n\n' "by default, sets to ${HOME}/hackreactor/"
      hack_path_1st=true
    else
      printf '\n%s\n' "OK. I understand you want a custom dir"
      printf '%s\n'   "please enter ABSOLUTE path starting at /"
      printf '%s\n'   "and include a trailing /"
      printf '%s\n\n' "ex. ${HOME}/hackreactor/"
      read -r -p "enter dir path to clone forked HR repos to: " hack_path
      if [ -d "$hack_path" ]; then
        printf '\n%s\n' "$hack_path"
        printf '%s\n'   "^THIS^ path?"
      else
        printf '\n%s\n' "Well! I reckon that ain't even a dir"
        yes_no "I'm fixin' to create such a dir" "I dun gooft. Lemme try again."
        if [ "$?" -eq 0 ]; then
          printf '\n%s\n' "okie dokie, making dir..."
          printf '%s\n\n' "$hack_path"
        fi
      fi
    fi
    #yes_no thatsthedir customize
  }
  custom_choice hack_path_pickr "that's the dir!" \
    "I'd like to customize a different dir location"

  mkdir -pv "$hack_path"

  "$_sed" -i "/^####\[ HackReactor path/a hack_path=\"$hack_path\"" "$script_path"
  if ! grep -q 'hack_path=' ./spgi; then
    "$_sed" -i "/^####\[ HackReactor path/a hack_path=\"$hack_path\"" ./spgi
  fi
fi

if [ -z "$ppgi_path" ]; then
  setup_banner
  ppgi_path_pickr() {
    ppgi_path='/usr/local/bin/'
    if [ -z "$ppgi_path_1st" ]; then
      printf '\n\n%s\n' "installing this script to your \$PATH"
      printf '%s\n'     "so that you can run it from anywhere in your shell"
      printf '%s\n\n'   "by default, installs to /usr/local/bin/"
      ppgi_path_1st=true
    else
      printf '\n%s\n' "OK. I understand you want to customize the install path"
      printf '%s\n'   "please enter ABSOLUTE path starting at /"
      printf '%s\n'   "and include a trailing /"
      printf '%s\n\n' "ex. /usr/local/bin/"
      read -r -p "enter the path to install ppgi to: " ppgi_path
      if [ -d "$ppgi_path" ]; then
        printf '\n%s\n' "$ppgi_path"
        printf '%s\n'   "^THIS^ path?"
      fi
    fi
  }
  custom_choice ppgi_path_pickr "that's the path!" \
    "I'd like to customize a different install path"

  "$_sed" -i "/^####\[ ppgi install DIR/a ppgi_path=\"${ppgi_path}ppgi\"" "$script_path"
  if ! grep -q 'hack_path=' ./spgi; then
    "$_sed" -i "/^####\[ ppgi install DIR/a ppgi_path=\"${ppgi_path}ppgi\"" ./spgi
  fi
  printf '\n%s\n'  "installing ppgi to ${ppgi_path}..."
  printf '%s %s\n' "copying script to install path: " "$ppgi_path"
  printf '%s\n'    "this might require SU (SuperUser) permissions..."
  sudo cp "${script_path}" "${ppgi_path}"
fi

# bash aliases
setup_banner
printf '%s\n\n' "OPTIONAL bash aliases..."
printf '%s\n' "do you want to add the bash alias 'pomander'?"
printf '%s\n\n' " desc: 'pomander' installs pomander at whatever pwd you're at"
#also check if it's currently in aliases
# if grep 'pomander' ~/.bash_aliases
yes_no "add pomander alias to bash" "do not add alias" &&\
  pom_url='https://raw.githubusercontent.com/reactorcore/pomander/master/bin/install' &&\
  printf '%s\n' "alias pomander='curl -s ${pom_url} | bash'" >> ~/.bash_aliases

printf '\n%s\n' "do you want to add the bash alias 'cdh'?"
printf '%s\n\n' " desc: 'cdh' will cd to your chosen HR dir from anywhere"
yes_no "add cdh alias to bash" "do not add alias" &&\
  printf '%s\n' "alias cdh='cd ${hack_path}'" >> ~/.bash_aliases
if [ "$OS" = "macos" ]; then
  . "${HOME}/.bash_profile"
else
  . "${HOME}/.bashrc"
fi

printf '%s\n\n' "ppgi setup complete."
printf '%s\n' "ppgi has been added to your \$PATH"
printf '%s\n' "you can now run ppgi from anywhere in your terminal"
printf '%s\n%s\n\n' "just enter the command: " "ppgi"
printf '%s\n' "Goodbye. :]"
exit 0
